# 核心功能详解

<cite>
**本文档引用文件**   
- [CommProMitsubishiQBinary.cpp](file://CommTest_Qt/Comm/Protocol/CommProMitsubishiQBinary.cpp)
- [CommProKeyencePCLink.cpp](file://CommTest_Qt/Comm/Protocol/CommProKeyencePCLink.cpp)
- [CommTest_Qt.cpp](file://CommTest_Qt/Gui/CommTest_Qt.cpp)
- [ScriptEditor.cpp](file://CommTest_Qt/Gui/ScriptEditor.cpp)
- [SubMainWindow.cpp](file://CommTest_Qt/Gui/SubMainWindow.cpp)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp)
- [LuaScript.cpp](file://CommTest_Qt/LuaScript/LuaScript.cpp)
- [CommProtocolBase.h](file://CommTest_Qt/Comm/Protocol/CommProtocolBase.h)
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h)
- [LuaScript.h](file://CommTest_Qt/LuaScript/LuaScript.h)
- [ScriptEditor.h](file://CommTest_Qt/Gui/ScriptEditor.h)
- [SubMainWindow.h](file://CommTest_Qt/Gui/SubMainWindow.h)
</cite>

## 目录
1. [PLC通信协议支持](#plc通信协议支持)
2. [图形用户界面](#图形用户界面)
3. [自动化测试](#自动化测试)
4. [网络通信模式](#网络通信模式)

## PLC通信协议支持

CommTest_Qt_CMake项目实现了对三菱Q系列二进制协议和基恩士PC-LINK协议的完整支持。两种协议均继承自`CommProtocolBase`抽象基类，通过`AnalyzeCmdInfo`、`AnalyzeReadReg`、`AnalyzeWriteReg`等纯虚函数定义了统一的解析接口。`CommProMitsubishiQBinary`类处理三菱MC 3E帧二进制通信，其报文格式以`500000FFFF0300`为指令头，包含数据长度、时间、指令码、地址类型和寄存器地址等字段。`CheckCmdInfoValid`函数负责校验报文完整性，`CmdInfoProcessing`函数在接收时将十六进制字符串转换为二进制数据，在发送时执行逆向转换。`PackReportReadRegInfo`和`PackReportWriteRegInfo`函数则负责构建符合协议规范的响应报文。基恩士PC-LINK协议由`CommProKeyencePCLink`类实现，采用ASCII文本指令，如`RDS`表示读寄存器，`WRS`表示写寄存器，数据格式为`.H`（十六进制），寄存器类型为`DM`。该协议无需额外的数据处理，`CmdInfoProcessing`为空实现。两种协议的指令类型通过`m_mCmdInfoType`映射表进行管理，确保了指令解析的高效性。

**Section sources**
- [CommProMitsubishiQBinary.cpp](file://CommTest_Qt/Comm/Protocol/CommProMitsubishiQBinary.cpp#L1-L191)
- [CommProKeyencePCLink.cpp](file://CommTest_Qt/Comm/Protocol/CommProKeyencePCLink.cpp#L1-L137)
- [CommProtocolBase.h](file://CommTest_Qt/Comm/Protocol/CommProtocolBase.h#L1-L107)

## 图形用户界面

主界面`CommTest_Qt`提供了直观的寄存器数据展示、通信日志记录和协议配置面板。寄存器数据显示在`table_RegisterData`表格中，分为地址列和值列，支持从指定地址开始的连续显示。`InitRegisterTable`函数初始化表格结构，`UpdateTableInfo`函数根据当前地址和数据类型更新表格内容。用户可通过`edit_RegisterAddr`输入框修改起始地址，并通过`cmbBox_DataType`下拉框选择数据类型（字符、单字、双字、单精度、双精度）。数据格式可通过`Radio_Data_DEC`和`Radio_Data_HEX`单选按钮在十进制和十六进制间切换。通信日志显示在`text_CommLog`文本框中，支持ASCII和十六进制两种显示模式。协议配置面板允许用户选择`基恩士PC-LINK上位链路协议`或`三菱MC协议二进制通信`。`SubMainWindow`类实现了小窗口操作模式，提供6个可自定义的快捷按钮和一个“退出小窗”按钮。主窗口通过`Btn_HideMainWindow`按钮隐藏自身并显示小窗口，小窗口通过`showMainWindow`信号通知主窗口重新显示，实现了主窗口与小窗口间的无缝切换。

**Section sources**
- [CommTest_Qt.cpp](file://CommTest_Qt/Gui/CommTest_Qt.cpp#L1-L800)
- [CommTest_Qt.h](file://CommTest_Qt/Gui/CommTest_Qt.h#L1-L147)
- [SubMainWindow.cpp](file://CommTest_Qt/Gui/SubMainWindow.cpp#L1-L45)
- [SubMainWindow.h](file://CommTest_Qt/Gui/SubMainWindow.h#L1-L95)

## 自动化测试

`ScriptEditor`类集成了Lua脚本的编辑与执行控制功能，支持循环测试和实时调试。编辑器提供语法高亮、函数模板插入、编译检查和执行功能。`LuaHighlighter`类实现了Lua关键字、注释、字符串和自定义函数的语法高亮。`functionTemplates`成员变量预定义了`SetInt16`、`GetInt16`等常用函数的调用模板。用户可通过“编译脚本”（F7）检查语法错误，通过“执行脚本”（F5）运行脚本。`LuaScript`类作为Lua虚拟机的封装，通过`RegisterLuaFunc`函数将C++的`SetInt16`、`GetInt16`等方法注册为Lua全局函数。这些函数通过`SetInt16Wrapper`等静态包装器，利用`lua_pushlightuserdata`将`this`指针传递给Lua，从而在Lua脚本中调用C++对象的方法。`RunLuaScript`函数加载并执行Lua文件，`RunLuaScriptWithEditor`函数执行编辑器中的脚本内容。循环测试通过`ChkBox_LoopEnable_X`复选框控制，`SetLoopValid`函数设置循环状态，`IsLoopValid`函数在Lua脚本中用于判断循环是否继续。`MainWorkFlow`类管理6个`LuaScript`实例，通过`RunLuaScript`函数执行指定索引的脚本，实现了多脚本并行测试的能力。

**Section sources**
- [ScriptEditor.cpp](file://CommTest_Qt/Gui/ScriptEditor.cpp#L1-L367)
- [ScriptEditor.h](file://CommTest_Qt/Gui/ScriptEditor.h#L1-L95)
- [LuaScript.cpp](file://CommTest_Qt/LuaScript/LuaScript.cpp#L1-L764)
- [LuaScript.h](file://CommTest_Qt/LuaScript/LuaScript.h#L1-L146)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp#L1-L544)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h#L1-L119)

## 网络通信模式

系统支持服务端/客户端模式下的Socket通信。`CommSocket`类继承自`CommBase`，实现了`Open`、`Close`、`SendData`等虚函数。当通信类型为`eSTServer`时，`initializeServer`函数创建`QTcpServer`实例并开始监听，通过`newConnection`信号接收新客户端连接，并为每个客户端创建`QTcpSocket`实例，存储在`m_ClientMap`中。`AddToRequestQueue`函数将接收到的数据包加入`m_requestQueue`请求队列，并触发`ProcessNextRequest`处理。`ProcessNextRequest`函数从队列头部取出请求，通过`dataReceived`信号通知上层应用。`SendData`函数从队列中取出当前处理的请求，向对应的客户端发送数据，并通过`dataSend`信号记录日志。`m_timeoutTimer`定时器用于检测请求超时，确保通信的可靠性。`MainWorkFlow`类作为通信工作流的中心，通过`OpenComm`函数创建`CommSocket`实例，并连接其`dataReceived`和`dataSend`信号到自身的`WorkProcess`槽函数。`WorkProcess`函数解析接收到的指令，调用`CommProtocolBase`的相应方法进行读写操作，并通过`WorkProcess_SendCommInfo`函数发送响应，形成了完整的服务端响应流程。

**Section sources**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L1-L342)
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L1-L114)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp#L1-L544)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h#L1-L119)