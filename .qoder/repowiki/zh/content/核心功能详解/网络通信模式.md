# 网络通信模式

<cite>
**本文档引用文件**   
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp)
- [CommBase.h](file://CommTest_Qt/Comm/CommBase.h)
- [CommProtocolBase.h](file://CommTest_Qt/Comm/Protocol/CommProtocolBase.h)
- [CommProMitsubishiQBinary.h](file://CommTest_Qt/Comm/Protocol/CommProMitsubishiQBinary.h)
- [CommProKeyencePCLink.h](file://CommTest_Qt/Comm/Protocol/CommProKeyencePCLink.h)
</cite>

## 目录
1. [项目结构](#项目结构)
2. [核心组件分析](#核心组件分析)
3. [通信架构概述](#通信架构概述)
4. [详细组件分析](#详细组件分析)
5. [通信调度流程](#通信调度流程)
6. [数据包队列机制](#数据包队列机制)
7. [服务端与客户端模式](#服务端与客户端模式)
8. [错误处理与超时机制](#错误处理与超时机制)
9. [性能优化建议](#性能优化建议)
10. [网络抓包分析示例](#网络抓包分析示例)

## 项目结构

```mermaid
graph TD
A[CommTest_Qt] --> B[Comm]
A --> C[Gui]
A --> D[MainFlow]
A --> E[LuaScript]
B --> F[Socket]
B --> G[Protocol]
F --> H[CommSocket.h]
F --> I[CommSocket.cpp]
G --> J[CommProKeyencePCLink.h]
G --> K[CommProMitsubishiQBinary.h]
G --> L[CommProtocolBase.h]
D --> M[MainWorkFlow.h]
D --> N[MainWorkFlow.cpp]
E --> O[LuaScript.h]
E --> P[LuaScript.cpp]
```

**图示来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h)
- [CommProtocolBase.h](file://CommTest_Qt/Comm/Protocol/CommProtocolBase.h)

**本节来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h)

## 核心组件分析

本系统基于Qt框架构建，核心通信功能由`CommSocket`类实现，该类继承自`CommBase`基类，通过`QTcpSocket`和`QTcpServer`实现TCP/IP通信。`MainWorkFlow`类作为主工作流控制器，协调通信、协议解析和数据处理。

`CommSocket`类支持服务端和客户端两种通信模式，通过`SocketType`枚举区分。通信参数通过`SocketCommInfo`结构体配置，包含IP地址、端口号和监听数量等关键信息。

**本节来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L14-L107)
- [CommBase.h](file://CommTest_Qt/Comm/CommBase.h#L3-L57)

## 通信架构概述

```mermaid
graph LR
Client[客户端] --> |TCP连接| Server[CommSocket]
Server --> |数据接收| Queue[请求队列]
Queue --> |异步处理| Protocol[协议解析]
Protocol --> |数据处理| Register[寄存器管理]
Register --> |响应生成| Server
Server --> |数据发送| Client
subgraph MainFlow
Protocol
Register
Lua[Lua脚本引擎]
end
Register --> |数据变更| GUI[GUI更新]
Lua --> |脚本执行| Register
```

**图示来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h)
- [CommProtocolBase.h](file://CommTest_Qt/Comm/Protocol/CommProtocolBase.h)

**本节来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L13-L107)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h#L29-L112)

## 详细组件分析

### CommSocket类分析

`CommSocket`类是网络通信的核心实现，封装了TCP连接管理、数据收发和错误处理功能。

```mermaid
classDiagram
class CommSocket {
+SocketType m_SocketType
+QString m_strSocketIPAddress
+uint32_t m_nSocketPort
+QTcpServer* m_Server
+QTcpSocket* m_Client
+QMap<QString, QTcpSocket*> m_ClientMap
+QQueue<PendingRequest> m_requestQueue
+QMutex m_queueMutex
+QTimer* m_timeoutTimer
+Open(CommInfoBase* commInfo) bool
+Close() bool
+SendData(const QByteArray& strData) bool
+IsOpen() bool
-initializeServer() bool
-initializeClient() bool
-Cleanup() void
-ProcessNextRequest() void
-AddToRequestQueue(const QString&, const QByteArray&) void
}
class CommBase {
+CommType GetCommType() CommType
+Open(CommInfoBase* commInfo) bool
+Close() bool
+IsOpen() bool
+SendData(const QByteArray& strData) bool
}
CommSocket --|> CommBase : 继承
class PendingRequest {
+QString clientId
+QByteArray requestData
+QDateTime timestamp
+bool isProcessing
+bool requiresResponse
+int timeoutMs
}
CommSocket --> PendingRequest : 包含
CommSocket --> QTcpServer : 使用
CommSocket --> QTcpSocket : 使用
```

**图示来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L13-L107)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L1-L342)

**本节来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L13-L107)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L1-L342)

### MainWorkFlow类分析

`MainWorkFlow`类作为系统主控制器，采用单例模式实现，负责协调通信、协议解析和数据处理。

```mermaid
classDiagram
class MainWorkFlow {
+static MainWorkFlow* s_pInstance
+static QMutex s_mutex
+std : : vector<std : : unique_ptr<LuaScript>> m_vpLuaScript
+std : : vector<std : : atomic_int16_t> m_RegisterVal
+std : : atomic_bool m_bDataChanged
+CommBase* m_pComm
+CommBase : : CommInfoBase* m_pCommInfo
+bool m_bValidComm
+CommProtocolBase* m_pComProBase
+InitialWorkFlow(QObject* pParent) MainWorkFlow*
+ReleaseWorkFlow() void
+SetCommInfo(CommBase : : CommInfoBase* commInfo) bool
+GetCommInfo() CommBase : : CommInfoBase*
+OpenComm() bool
+CloseComm() bool
+IsCommOpen() bool
+CreateCommProtocol(ProtocolType ProType) bool
+WorkProcess(QByteArray& RecInfo) void
+GetCommBase() CommBase*
+GetRegisterNum() long
+GetRegisterVal(int Addr) int16_t
+SetRegisterVal(int Addr, const int16_t& nsetVal) bool
+ResetAllRegisters(int16_t nsetVal) bool
+RunLuaScript(int nLuaIndex,const QString& strLuaFile) bool
+GetLuaScript(int nIndex) LuaScript*
}
MainWorkFlow --> CommSocket : 使用
MainWorkFlow --> CommProtocolBase : 使用
MainWorkFlow --> LuaScript : 使用
```

**图示来源**
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h#L29-L112)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp#L1-L544)

**本节来源**
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h#L29-L112)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp#L1-L544)

## 通信调度流程

系统采用事件驱动的异步通信模型，通信调度流程如下：

```mermaid
sequenceDiagram
participant Client as "客户端"
participant CommSocket as "CommSocket"
participant MainWorkFlow as "MainWorkFlow"
participant Protocol as "通信协议"
Client->>CommSocket : 发送数据
CommSocket->>CommSocket : 触发readyRead信号
CommSocket->>CommSocket : 调用AddToRequestQueue
CommSocket->>CommSocket : 将请求加入队列
CommSocket->>CommSocket : 调用ProcessNextRequest
CommSocket->>MainWorkFlow : 发出dataReceived信号
MainWorkFlow->>MainWorkFlow : 调用WorkProcess
MainWorkFlow->>MainWorkFlow : 调用WorkProcess_AnalyzeReceiveInfo
MainWorkFlow->>Protocol : 调用AnalyzeCmdInfo
Protocol-->>MainWorkFlow : 返回指令类型
MainWorkFlow->>MainWorkFlow : 根据指令类型调用相应处理函数
MainWorkFlow->>MainWorkFlow : 调用WorkProcess_WriteReg或WorkProcess_ReadReg
MainWorkFlow->>MainWorkFlow : 更新寄存器数据
MainWorkFlow->>MainWorkFlow : 调用WorkProcess_SendCommInfo
MainWorkFlow->>CommSocket : 调用SendData
CommSocket->>CommSocket : 从队列获取当前客户端
CommSocket->>CommSocket : 调用QTcpSocket : : write
CommSocket->>Client : 发送响应数据
CommSocket->>CommSocket : 调用ProcessNextRequest处理下一个请求
```

**图示来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L85-L92)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp#L323-L369)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L216-L276)

**本节来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L85-L92)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp#L323-L369)

## 数据包队列机制

`CommSocket`类通过数据包队列机制保证消息有序性和线程安全，防止数据丢失或阻塞。

```mermaid
flowchart TD
Start([数据到达]) --> GetClientId["获取客户端ID"]
GetClientId --> AddToQueue["添加到请求队列"]
AddToQueue --> LockQueue["获取互斥锁"]
LockQueue --> Enqueue["将请求加入队列"]
Enqueue --> CheckProcessing["检查是否正在处理"]
CheckProcessing --> |否| ProcessNow["立即处理下一个请求"]
CheckProcessing --> |是| Wait["等待当前请求处理完成"]
ProcessNow --> ProcessNext["调用ProcessNextRequest"]
Wait --> ProcessNext
ProcessNext --> CheckQueue["检查队列是否为空"]
CheckQueue --> |是| End["结束"]
CheckQueue --> |否| MarkProcessing["标记请求正在处理"]
MarkProcessing --> StartTimer["启动超时定时器"]
StartTimer --> EmitSignal["发出dataReceived信号"]
EmitSignal --> WaitResponse["等待响应"]
WaitResponse --> SendData["调用SendData发送响应"]
SendData --> StopTimer["停止超时定时器"]
StopTimer --> RemoveRequest["从队列移除请求"]
RemoveRequest --> ProcessNext["处理下一个请求"]
ProcessNext --> End
```

**图示来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L84-L91)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L278-L299)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L302-L334)

**本节来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L84-L91)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L278-L299)

## 服务端与客户端模式

### 服务端模式

服务端模式下，`CommSocket`类使用`QTcpServer`监听指定端口，管理多个客户端连接。

```mermaid
sequenceDiagram
participant Server as "QTcpServer"
participant CommSocket as "CommSocket"
participant Client as "客户端"
Server->>CommSocket : newConnection信号
loop 处理所有待处理连接
CommSocket->>Server : hasPendingConnections()
Server-->>CommSocket : 返回true
CommSocket->>Server : nextPendingConnection()
Server-->>CommSocket : 返回QTcpSocket
CommSocket->>CommSocket : 调用GetClientId
CommSocket->>CommSocket : 将客户端加入m_ClientMap
CommSocket->>CommSocket : 连接readyRead信号
CommSocket->>CommSocket : 连接errorOccurred信号
CommSocket->>CommSocket : 连接disconnected信号
end
Server-->>CommSocket : 返回false
```

**图示来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L69-L118)
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h#L96-L97)

**本节来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L69-L118)

### 客户端模式

客户端模式下，`CommSocket`类使用`QTcpSocket`与真实PLC设备建立通信。

```mermaid
flowchart TD
Start([Open调用]) --> CheckType["检查通信类型"]
CheckType --> |服务端| InitializeServer["调用initializeServer"]
CheckType --> |客户端| InitializeClient["调用initializeClient"]
InitializeServer --> CreateServer["创建QTcpServer"]
CreateServer --> SetListenNum["设置监听数量"]
SetListenNum --> StartListen["开始监听"]
StartListen --> ConnectSignals["连接信号槽"]
ConnectSignals --> Success["返回true"]
InitializeClient --> NotImplemented["返回false(未实现)"]
Success --> End["结束"]
NotImplemented --> End
```

**图示来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L172-L198)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L129-L132)

**本节来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L172-L198)

## 错误处理与超时机制

系统实现了完善的错误处理和超时机制，确保通信的可靠性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant CommSocket as "CommSocket"
participant Timer as "超时定时器"
Client->>CommSocket : 发送数据
CommSocket->>CommSocket : 调用AddToRequestQueue
CommSocket->>CommSocket : 调用ProcessNextRequest
CommSocket->>Timer : 启动定时器
Timer->>Timer : 开始计时
alt 在超时前收到响应
Client->>CommSocket : 发送响应
CommSocket->>CommSocket : 调用SendData
CommSocket->>Timer : 停止定时器
CommSocket->>CommSocket : 处理下一个请求
else 超时未收到响应
Timer->>CommSocket : timeout信号
CommSocket->>CommSocket : 检查是否正在处理
CommSocket->>CommSocket : 记录超时日志
CommSocket->>CommSocket : 移除超时请求
CommSocket->>CommSocket : 处理下一个请求
end
```

**图示来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L14-L35)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L278-L299)
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L302-L334)

**本节来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp#L14-L35)

## 性能优化建议

1. **连接池优化**：对于频繁连接的场景，建议实现连接池机制，避免频繁创建和销毁连接。
2. **批量处理**：对于大量小数据包的场景，可以考虑批量处理，减少网络开销。
3. **线程优化**：对于高并发场景，可以考虑将数据处理逻辑放到独立线程中执行。
4. **内存优化**：合理设置缓冲区大小，避免内存浪费。
5. **协议优化**：根据实际需求选择合适的通信协议，减少协议开销。

**本节来源**
- [CommSocket.h](file://CommTest_Qt/Comm/Socket/CommSocket.h)
- [MainWorkFlow.h](file://CommTest_Qt/MainFlow/MainWorkFlow.h)

## 网络抓包分析示例

当遇到连接失败或超时等常见问题时，可以通过网络抓包进行诊断：

1. **连接失败**：检查TCP三次握手是否完成，确认服务器端口是否开放。
2. **数据丢失**：检查TCP序列号是否连续，确认是否有丢包现象。
3. **超时问题**：检查数据包往返时间，确认网络延迟是否过高。
4. **协议错误**：检查应用层数据格式是否符合协议规范。

通过Wireshark等工具抓包分析，可以直观地看到通信过程中的数据交互，帮助快速定位问题。

**本节来源**
- [CommSocket.cpp](file://CommTest_Qt/Comm/Socket/CommSocket.cpp)
- [MainWorkFlow.cpp](file://CommTest_Qt/MainFlow/MainWorkFlow.cpp)